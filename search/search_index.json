{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FMT-MPC","text":"<p>A modular Fast Marching Tree (FMT) planning and control stack for ground vehicles. The stack blends a safety-aware global planner, a model predictive controller (MPC), a deterministic bicycle-model simulator, and rich diagnostics to plan, track, and analyze end-to-end driving scenarios.</p>"},{"location":"#get-started","title":"Get started","text":"<ul> <li>Introduction</li> <li>System Architecture</li> <li>Planning &amp; Control</li> <li>Simulation &amp; Visualisation</li> <li>Configuration &amp; CLI</li> <li>Results</li> </ul>"},{"location":"01_introduction/","title":"Introduction","text":""},{"location":"01_introduction/#overview","title":"Overview","text":"<p>This repository implements a Fast Marching Tree (FMT)\u2013based autonomy stack for ground vehicle navigation in structured environments represented by occupancy grids. The system combines sampling-based global planning, model-predictive control, deterministic simulation, and scientific visualization into a unified framework for research-grade experimentation. Its primary design goals are reproducibility, scientific instrumentation, and modularity, allowing consistent comparison of experiments and precise inspection of algorithmic behavior.</p> <p>FMT planning offers the ability to compute high-quality motion trajectories through cluttered environments while preserving computational efficiency. The surrounding stack ensures that each subsystem\u2014from mapping to control\u2014operates on deterministic data, yielding identical results across repeated runs.</p>"},{"location":"01_introduction/#1-system-composition","title":"1. System Composition","text":"<p>The architecture integrates four interdependent scientific pillars:</p> <ol> <li> <p>Mapping    Constructs deterministic occupancy grids from images or specifications.</p> </li> <li> <p>Performs OpenCV-based obstacle inflation to impose clearance constraints.</p> </li> <li> <p>Annotates each grid with metric metadata (resolution, scale, and origin) to ensure consistent spatial interpretation throughout the pipeline.</p> </li> <li> <p>Planning    Implements a goal-biased Fast Marching Tree (FMT) planner to find feasible paths in the free configuration space \\(\\mathcal{X}_{\\mathrm{free}}\\).</p> </li> <li> <p>Generates a sparse graph of feasible connections respecting inflated safety corridors.</p> </li> <li>Produces detailed exploration logs capturing sampling, edge validation, and cost propagation.</li> <li> <p>Applies spline smoothing and corridor validation to generate curvature-continuous paths.</p> </li> <li> <p>Tracking    Uses a Model Predictive Controller (MPC) formulated in cvxpy.</p> </li> <li> <p>Linearizes vehicle dynamics along the planned reference.</p> </li> <li>Solves a constrained quadratic program (QP) at every timestep, yielding optimal acceleration and steering rate inputs.</li> <li> <p>Outputs both feedforward and feedback actions, as well as predicted state horizons for interpretability.</p> </li> <li> <p>Simulation &amp; Visualization    Provides a deterministic kinematic bicycle simulator and an extensive visualization layer.</p> </li> <li> <p>The simulator integrates the dynamics with fixed time discretization, ensuring repeatability.</p> </li> <li>Visual outputs include static dashboards, animated trajectories, and planner debug views.</li> <li>The result is a complete end-to-end diagnostic system capable of both numerical analysis and graphical validation.</li> </ol> <p>Scenario configurations are defined as YAML manifests (located in <code>configs/</code>), which specify the map, vehicle, planner, and visualization parameters. These configurations are executed by the command-line interface in <code>src/cli</code>, enabling selective subsystem execution or full end-to-end experiments.</p>"},{"location":"01_introduction/#2-theoretical-rationale-combining-fmt-and-mpc","title":"2. Theoretical Rationale: Combining FMT and MPC","text":""},{"location":"01_introduction/#21-fmt-global-sampling-based-optimization","title":"2.1. FMT: Global Sampling-Based Optimization","text":"<p>The Fast Marching Tree (FMT) algorithm constructs a sparse, directed acyclic graph of feasible motions by combining sampling-based exploration with dynamic programming principles. Given a set of free-space samples \\(\\mathcal{X}_{\\mathrm{free}} = \\{ x_i \\}\\), the planner seeks a path</p> \\[ \\xi = (x_0, x_1, \\dots, x_N) \\] <p>minimizing the geometric cost:</p> \\[ J(\\xi) = \\sum_{k=0}^{N-1} \\lVert x_{k+1} - x_k \\rVert_2, \\] <p>subject to all edges lying within the inflated safety corridor.</p> <p>FMT achieves asymptotic optimality while maintaining computational complexity comparable to Probabilistic Roadmaps (PRM). It incrementally expands a frontier of optimal partial paths and connects only nearby feasible nodes, drastically reducing redundant collision checks.</p>"},{"location":"01_introduction/#22-mpc-local-dynamic-optimization","title":"2.2. MPC: Local Dynamic Optimization","text":"<p>While FMT provides a collision-free global reference, it does not explicitly enforce dynamic constraints of the vehicle. To ensure feasible and stable motion, a Model Predictive Controller refines this reference online.</p> <p>At each control step, MPC solves the convex quadratic optimization problem:</p> \\[ \\begin{aligned} \\min_{u_{0:H-1}} \\quad &amp; \\sum_{k=0}^{H} \\lVert x_k - x_k^{\\mathrm{ref}} \\rVert_Q^2 + \\sum_{k=0}^{H-1} \\lVert u_k \\rVert_R^2 \\\\ \\text{s.t.} \\quad &amp; x_{k+1} = f(x_k, u_k), \\end{aligned} \\] <p>subject to the discretized vehicle model and actuator constraints, where \\(f(\\cdot)\\) denotes the discretized bicycle dynamics used throughout the stack. Here:</p> <ul> <li>\\(H\\): prediction horizon length.</li> <li>\\(x_k^{\\mathrm{ref}}\\): spline-sampled reference states along the FMT path.</li> <li>\\(Q\\), \\(R\\): positive-definite weighting matrices penalizing tracking error and control effort.</li> </ul> <p>The MPC adjusts the local vehicle behavior to remain dynamically feasible and robust to disturbances while adhering to the global plan.</p>"},{"location":"01_introduction/#23-coupled-hierarchy","title":"2.3. Coupled Hierarchy","text":"<p>The joint operation of FMT and MPC yields a hierarchical planning and control system:</p> <ul> <li>FMT defines the global corridor with guaranteed collision-free geometry.</li> <li>MPC enforces dynamic feasibility and real-time correction.</li> <li>The deterministic simulator ensures exact repeatability for all combinations of seeds and parameters.</li> </ul> <p>Together, they enable stable trajectory generation and control that can be replicated across experiments, ensuring reproducibility for research and benchmarking.</p>"},{"location":"01_introduction/#3-reproducibility-and-instrumentation","title":"3. Reproducibility and Instrumentation","text":"<p>The framework is built for scientific reproducibility and detailed instrumentation. Each component emits structured logs containing:</p> <ul> <li>Planner statistics (sample counts, connection radius, cost metrics).</li> <li>Controller diagnostics (solver convergence, constraint activations, error trajectories).</li> <li>Simulator states (pose, curvature, slip metrics).</li> <li>Visualization artifacts (map overlays, vehicle poses, predicted horizons).</li> </ul> <p>All numerical operations, from random sampling to time integration, are deterministic and seed-controlled, ensuring identical results across repeated runs.</p>"},{"location":"01_introduction/#4-usage-and-experimental-workflow","title":"4. Usage and Experimental Workflow","text":"<p>The experiment workflow proceeds as follows:</p> <ol> <li> <p>Scenario Definition:    Create or modify a YAML file specifying the map, vehicle model, planner parameters, and visualization options.</p> </li> <li> <p>Execution:    Run the desired subsystem or full pipeline via the <code>src/cli</code> command-line interface.</p> </li> <li> <p>Computation:    The stack executes the mapping, planning, smoothing, control, and simulation modules sequentially, generating a complete trajectory and log.</p> </li> <li> <p>Visualization and Analysis:    Visual outputs and log files provide both static and dynamic insight into the experiment, enabling quantitative performance evaluation.</p> </li> </ol> <p>This modular design supports reproducible studies, parameter sweeps, and comparative benchmarking of algorithmic variants under identical environmental conditions.</p>"},{"location":"01_introduction/#5-summary","title":"5. Summary","text":"<p>The repository delivers a scientifically structured, deterministic, and extensible autonomy stack integrating:</p> <ul> <li>Global motion planning via Fast Marching Tree (FMT).</li> <li>Dynamic control optimization via Model Predictive Control (MPC).</li> <li>Deterministic simulation ensuring bitwise repeatability.</li> <li>Comprehensive visualization and logging for analytical traceability.</li> </ul> <p>By uniting global optimality with local dynamic feasibility, the framework enables rigorous experimentation in autonomous ground vehicle motion planning and control, bridging theoretical soundness with reproducible practical execution.</p>"},{"location":"02_system_architecture/","title":"System Architecture","text":""},{"location":"02_system_architecture/#overview","title":"Overview","text":"<p>The repository implements a modular and scientifically rigorous architecture for autonomous vehicle planning, control, and simulation. Each subsystem\u2014mapping, planning, vehicle dynamics, optimization, visualization, and logging\u2014resides in an isolated package with a well-defined interface. This compartmentalization ensures component-level replaceability, minimal coupling, and deterministic reproducibility across simulations.</p> <p>The system is designed around data-driven configuration, clear inter-module contracts, and reproducible computation, enabling users to modify planners, vehicle models, or visualization components without affecting the rest of the framework.</p>"},{"location":"02_system_architecture/#1-data-flow-overview","title":"1. Data Flow Overview","text":"<p>The overall pipeline follows a sequential yet modular execution chain, depicted below:</p> <pre><code>graph LR\n    A[Scenario YAML] --&gt; B[Configuration Loader]\n    B --&gt; C[Mapping]\n    C --&gt; D[FMT Planner]\n    D --&gt; E[Trajectory Smoother]\n    E --&gt; F[MPC Tracker]\n    F --&gt; G[Simulator]\n    G --&gt; H[Visualisation]\n    H --&gt; I[Artifacts]</code></pre> <p>Each stage transforms structured inputs into typed outputs that serve as inputs to subsequent modules. The interfaces are implemented via typed dataclasses and explicit contracts, ensuring static consistency and runtime integrity.</p>"},{"location":"02_system_architecture/#2-core-modules","title":"2. Core Modules","text":""},{"location":"02_system_architecture/#21-configuration-srccommonconfigpy","title":"2.1. Configuration (<code>src/common/config.py</code>)","text":"<p>Purpose: Define and validate simulation and system parameters from YAML scenario files.</p> <p>Technical details:</p> <ul> <li>Uses Python dataclasses with strict type annotations for every parameter.</li> <li>Validates field structures and permissible ranges.</li> <li>Seeds all pseudo-random number generators (<code>numpy</code>, <code>random</code>, etc.) to ensure deterministic sampling and reproducible randomization in planning.</li> <li>Provides bidirectional mapping between YAML schema and runtime configuration objects.</li> <li>Comprehensive docstrings establish explicit configuration contracts.</li> </ul> <p>Outcome: Guarantees repeatable experiments, stable parameter propagation, and clear traceability between YAML scenarios and code execution.</p>"},{"location":"02_system_architecture/#22-mapping-srcmapping","title":"2.2. Mapping (<code>src/mapping/</code>)","text":"<p>Purpose: Generate and preprocess the environment representation for the planner.</p> <p>Processing steps:</p> <ol> <li>Loads binary occupancy grids from deterministic specifications or bitmap images (PNG format).</li> <li>Applies morphological inflation using OpenCV to construct inflated obstacle maps that maintain safety margins around physical obstacles.</li> <li>Computes Euclidean distance transforms, yielding a scalar field \\(d_{\\mathrm{obs}}(x)\\) that encodes clearance from obstacles at every grid cell.</li> </ol> <p>Outputs:</p> <ul> <li>Original occupancy map \\(\\mathcal{O}\\)</li> <li>Inflated map \\(\\mathcal{I}\\)</li> <li>Continuous distance field for clearance evaluation.</li> </ul> <p>Scientific role: Enables consistent safety evaluation and real-time feasibility checking during planning and simulation.</p>"},{"location":"02_system_architecture/#23-planning-srcplanningfmt_plannerpy","title":"2.3. Planning (<code>src/planning/fmt_planner.py</code>)","text":"<p>Purpose: Compute collision-free, near-optimal reference paths through the configuration space.</p> <p>Key features:</p> <ul> <li>Implements Fast Marching Tree (FMT*) algorithm for asymptotically optimal path planning.</li> <li>Samples free configurations from \\(\\mathcal{X}_{\\mathrm{free}}\\) with goal biasing to accelerate convergence.</li> <li>Connects nodes within a radius \\(r_n = \\gamma (\\log n / n)^{1/d}\\), following theoretical optimality bounds.</li> <li>Validates edges using the inflated safety corridor and the precomputed distance transform.</li> <li>Records exploration statistics, including rejected edges, accepted nodes, and computational time.</li> </ul> <p>Scientific significance: Balances computational efficiency with formal asymptotic guarantees, enabling rigorous comparison across runs.</p>"},{"location":"02_system_architecture/#24-trajectory-smoothing-srctrackingmpc_trackerpy-and-intermediary-smoothing-stage","title":"2.4. Trajectory Smoothing (<code>src/tracking/mpc_tracker.py</code> and intermediary smoothing stage)","text":"<p>Purpose: Transform discrete waypoints from the planner into curvature-continuous, differentiable reference trajectories for MPC tracking.</p> <p>Methods:</p> <ul> <li>Uses arc-length reparameterization to obtain uniformly spaced reference samples.</li> <li>Applies centripetal Catmull\u2013Rom interpolation (\\(\\alpha = 0.5\\)) to avoid overshooting near sharp turns.</li> <li>Validates post-smoothing path against the inflated corridor to preserve clearance constraints.</li> </ul> <p>Output: A smooth trajectory with continuous position, curvature, and heading derivatives suitable for model-based control.</p>"},{"location":"02_system_architecture/#25-tracking-srctrackingmpc_trackerpy","title":"2.5. Tracking (<code>src/tracking/mpc_tracker.py</code>)","text":"<p>Purpose: Perform constrained optimal control using Model Predictive Control (MPC).</p> <p>Implementation details:</p> <ul> <li>Linearizes kinematic bicycle dynamics along the reference trajectory.</li> <li>Constructs discrete-time linear systems \\(x_{k+1} = A_k x_k + B_k u_k + c_k\\).</li> <li> <p>Solves a convex Quadratic Program (QP) formulated in CVXPY, incorporating:</p> </li> <li> <p>State and control cost terms \\(\\lVert x_k - x_k^{\\mathrm{ref}} \\rVert_Q^2\\), \\(\\lVert u_k - u_k^{\\mathrm{ref}} \\rVert_R^2\\),</p> </li> <li>Velocity, steering, and actuation constraints.</li> <li>Executes in receding-horizon fashion, applying only the first optimal control at each iteration.</li> </ul> <p>Scientific outcome: Realizes real-time, constraint-aware vehicle control with guaranteed convexity and stability margins.</p>"},{"location":"02_system_architecture/#26-vehicle-model-srcvehiclebicyclepy","title":"2.6. Vehicle Model (<code>src/vehicle/bicycle.py</code>)","text":"<p>Purpose: Encapsulate the kinematic bicycle dynamics for both forward simulation and linearization.</p> <p>Functionalities:</p> <ul> <li>Provides analytic state-update equations for position, heading, and velocity.</li> <li>Computes curvature \\(\\kappa = \\tan(\\delta)/L\\), slip ratio, and lateral acceleration.</li> <li>Supplies Jacobian matrices ( A, B ) for MPC linearization.</li> <li>Includes instrumentation to monitor numerical consistency of curvature and slip metrics.</li> </ul> <p>Scientific contribution: Establishes a physically interpretable and mathematically tractable model for real-time control.</p>"},{"location":"02_system_architecture/#27-simulation-srcsimsimulatorpy","title":"2.7. Simulation (<code>src/sim/simulator.py</code>)","text":"<p>Purpose: Execute a closed-loop deterministic simulation integrating planning, tracking, and control under realistic dynamics.</p> <p>Mechanism:</p> <ul> <li>Uses a fixed-step deterministic integration loop for \\(T / \\Delta t\\) iterations.</li> <li>Sequentially invokes the MPC tracker, applies controls, updates vehicle states, and logs diagnostics.</li> <li>Terminates when vehicle velocity drops below a configurable threshold after reaching the end of the reference path.</li> </ul> <p>Output: A structured <code>SimulationLog</code> containing per-step state vectors, control commands, MPC predictions, and tracking errors.</p> <p>Scientific value: Enables repeatable experiments, convergence analysis, and consistent quantitative evaluation.</p>"},{"location":"02_system_architecture/#28-visualization-srcvis","title":"2.8. Visualization (<code>src/vis/</code>)","text":"<p>Purpose: Render simulation and planning outputs into interpretable figures and animations.</p> <p>Components:</p> <ul> <li>Static dashboards: Combine map views, velocity and acceleration plots, steering, error metrics, and force diagrams.</li> <li>Animated trajectories: Display vehicle evolution, MPC horizon predictions, and obstacle interaction in real time.</li> <li>FMT debug visualizations: Illustrate sampling and tree expansion behavior for algorithmic inspection.</li> </ul> <p>Scientific function: Provides reproducible visual evidence of planner and controller performance for publication or analysis.</p>"},{"location":"02_system_architecture/#29-logging-srccommonlogging_utilspy","title":"2.9. Logging (<code>src/common/logging_utils.py</code>)","text":"<p>Purpose: Centralize logging configuration for all modules.</p> <p>Features:</p> <ul> <li>Uniform timestamping, module name tagging, and severity level formatting.</li> <li>Dual-channel logging: console output and synchronized <code>.log</code> files.</li> <li>Ensures perfect temporal alignment between runtime messages and stored simulation artifacts.</li> </ul> <p>Result: Guarantees traceability and reproducibility across multiple experimental runs.</p>"},{"location":"02_system_architecture/#3-testing-and-validation","title":"3. Testing and Validation","text":"<p>Location: <code>tests/</code></p> <p>Coverage:</p> <ul> <li>Unit tests: Validate individual module correctness (mapping, dynamics, FMT connectivity, MPC feasibility).</li> <li>Integration tests: Verify complete end-to-end functionality from configuration loading to visualization artifact generation.</li> <li>Includes both conservative (slow-speed, tight-clearance) and high-speed scenarios to test numerical stability and control robustness.</li> </ul> <p>Scientific guarantee: Ensures every subsystem adheres to defined physical, mathematical, and numerical contracts under varying operating conditions.</p>"},{"location":"02_system_architecture/#4-summary","title":"4. Summary","text":"<p>The System Architecture is engineered for modularity, determinism, and scientific reproducibility. Key architectural principles:</p> <ol> <li>Isolated scientific domains: Each package encapsulates a single research concern.</li> <li>Deterministic execution: Fixed-seed randomization and discretized integration grids eliminate non-determinism.</li> <li>Explicit configuration contracts: YAML-driven dataclasses ensure transparency between configuration and execution.</li> <li>Layered design: Separation of mapping, planning, control, and visualization enables targeted experimentation.</li> <li>Comprehensive testing: Unit and integration coverage verify algorithmic correctness across conditions.</li> </ol> <p>This structured, modular framework supports research reproducibility, facilitates algorithmic substitution, and provides a robust foundation for autonomous system development and evaluation.</p>"},{"location":"03_planning_and_control/","title":"Planning and Control","text":""},{"location":"03_planning_and_control/#overview","title":"Overview","text":"<p>This document provides a comprehensive and scientific explanation of the Planning and Control module, which integrates the Fast Marching Tree (FMT) planner, a curvature-continuous smoothing pipeline, and a Model Predictive Control (MPC) tracker. The system enables efficient motion planning and robust trajectory tracking for ground vehicles operating in static environments represented by occupancy grids. The design emphasizes algorithmic rigor, numerical stability, and safety guarantees.</p>"},{"location":"03_planning_and_control/#1-fmt-planner","title":"1. FMT Planner","text":""},{"location":"03_planning_and_control/#11-mathematical-foundation","title":"1.1. Mathematical Foundation","text":"<p>The Fast Marching Tree (FMT) planner is a sampling-based algorithm that computes approximately optimal paths in continuous configuration spaces. It operates on an inflated occupancy grid to ensure a fixed safety buffer around obstacles.</p> <p>Let:</p> <ul> <li>\\(\\mathcal{X}_{\\mathrm{free}} \\subset \\mathbb{R}^d\\): free configuration space.</li> <li>\\(n\\): number of sampled configurations.</li> <li>\\(r_n\\): connection radius.</li> <li>\\(\\gamma &gt; 1\\): tunable graph density constant.</li> </ul> <p>The connection radius follows the asymptotically optimal scaling law:</p> \\[ r_n = \\gamma \\left(\\frac{\\log n}{n}\\right)^{1/d}. \\] <p>For \\(d = 2\\), this ensures probabilistic completeness and asymptotic optimality under mild assumptions on the environment\u2019s geometry.</p>"},{"location":"03_planning_and_control/#12-safety-aware-space-inflation","title":"1.2. Safety-Aware Space Inflation","text":"<p>The occupancy grid consists of:</p> <ul> <li>\\(\\mathcal{O}\\): binary obstacle bitmap.</li> <li>\\(\\mathcal{I}\\): inflated bitmap obtained by morphological dilation with radius \\(\\delta\\).</li> </ul> <p>The inflation radius \\(\\delta\\) defines a clearance constraint:</p> \\[ d_{\\mathrm{obs}}(x_i) &gt; \\delta, \\] <p>where \\(d_{\\mathrm{obs}}\\) is the Euclidean distance transform of the obstacle layer. This ensures the planner rejects any samples violating the safety margin.</p>"},{"location":"03_planning_and_control/#13-algorithmic-stages","title":"1.3. Algorithmic Stages","text":"<p>The planner operates through four deterministic phases:</p> <pre><code>graph TD\n    A[Sample Free Space] --&gt; B[Prune Colliding Nodes]\n    B --&gt; C[Grow Goal-Biased Tree]\n    C --&gt; D[Rewire for Shorter Paths]\n    D --&gt; E[Validate Corridor]\n    E --&gt; F[Smooth Path]</code></pre>"},{"location":"03_planning_and_control/#131-sampling","title":"1.3.1. Sampling","text":"<p>Uniform and goal-biased random samples are generated in \\(\\mathcal{X}_{\\mathrm{free}}\\). A fixed random seed ensures repeatability across runs.</p>"},{"location":"03_planning_and_control/#132-tree-growth","title":"1.3.2. Tree Growth","text":"<p>At each iteration:</p> <ul> <li>The frontier node \\(x\\) with the minimum accumulated cost is selected.</li> <li>All candidate nodes \\(y\\) within distance \\(r_n\\) are inspected:</li> </ul> <p>$$   \\lVert x - y \\rVert_2 \\le r_n.   $$</p> <ul> <li>The edge \\((x, y)\\) is accepted only if the discretized segment satisfies</li> </ul> <p>$$   d_{\\mathrm{obs}}(s) &gt; \\delta, \\quad \\forall s \\in [x, y].   $$</p> <p>This check ensures no part of the connection crosses inflated obstacles.</p>"},{"location":"03_planning_and_control/#133-rewiring-and-pruning","title":"1.3.3. Rewiring and Pruning","text":"<p>If a newly discovered path offers a lower cumulative cost, the tree rewires the parent relationship of the node, reducing the path length and improving the optimality bound as \\(n \\to \\infty\\).</p>"},{"location":"03_planning_and_control/#134-corridor-validation","title":"1.3.4. Corridor Validation","text":"<p>After initial path generation, the planner validates the smoothed path\u2019s adherence to the inflated corridor. If a violation occurs, the system falls back to the unsmoothed waypoint chain, maintaining safety guarantees.</p>"},{"location":"03_planning_and_control/#14-computational-notes","title":"1.4. Computational Notes","text":"<ul> <li>Each node stores cumulative cost, parent index, and clearance metadata.</li> <li>The FMT expansion uses a min-heap for cost ordering, ensuring \\(O(n \\log n)\\) complexity.</li> <li>Visualization and logging record both successful and rejected connections for diagnostic and reproducibility purposes.</li> </ul>"},{"location":"03_planning_and_control/#2-path-smoothing","title":"2. Path Smoothing","text":""},{"location":"03_planning_and_control/#21-motivation","title":"2.1. Motivation","text":"<p>The raw waypoint path generated by FMT lacks curvature continuity, which can destabilize model-based controllers. A smoothing stage based on centripetal Catmull\u2013Rom splines creates a differentiable path suitable for feedforward control and preview-based tracking.</p>"},{"location":"03_planning_and_control/#22-formulation","title":"2.2. Formulation","text":"<p>Given waypoints \\(\\{ p_i \\}_{i=0}^N\\), the parameterization uses centripetal spacing:</p> \\[ t_{i+1} = t_i + \\lVert p_{i+1} - p_i \\rVert_2^{\\alpha}, \\quad \\alpha = \\tfrac{1}{2}. \\] <p>This reduces oscillations near sharp corners and avoids overshooting, a known issue with uniform parameterizations.</p>"},{"location":"03_planning_and_control/#23-sampling-and-safety-revalidation","title":"2.3. Sampling and Safety Revalidation","text":"<p>The spline is resampled at constant arc-length increments \\(\\Delta s\\), producing \\(\\{ \\tilde{p}_j \\}_{j=0}^M\\). Each interpolated point is checked against the distance field:</p> \\[ d_{\\mathrm{obs}}(\\tilde{p}_j) &gt; \\delta. \\] <p>If violations occur, points are clipped to the valid configuration space. This guarantees geometric feasibility post-smoothing.</p>"},{"location":"03_planning_and_control/#24-output-properties","title":"2.4. Output Properties","text":"<ul> <li>Continuity: \\(C^1\\) continuity in position and heading.</li> <li>Differentiability: Required for curvature and velocity computation.</li> <li>Bounded curvature: Enables stable reference generation for the MPC.</li> </ul>"},{"location":"03_planning_and_control/#3-mpc-tracker","title":"3. MPC Tracker","text":""},{"location":"03_planning_and_control/#31-kinematic-bicycle-model","title":"3.1. Kinematic Bicycle Model","text":"<p>The tracking controller employs the linearized kinematic bicycle model. Let the state vector be:</p> \\[ x = [e_y, e_\\psi, v, \\kappa]^\\top, \\] <p>and control vector:</p> \\[ u = [a, \\dot{\\delta}]^\\top, \\] <p>where:</p> <ul> <li>\\(e_y\\): lateral offset error,</li> <li>\\(e_\\psi\\): heading error,</li> <li>\\(v\\): longitudinal velocity,</li> <li>\\(\\kappa\\): curvature,</li> <li>\\(a\\): acceleration input,</li> <li>\\(\\dot{\\delta}\\): steering rate input.</li> </ul> <p>The discrete linearized dynamics are:</p> \\[ x_{k+1} = A_k x_k + B_k u_k + c_k, \\] <p>where \\(A_k\\) and \\(B_k\\) are Jacobians computed at the current reference state, and \\(c_k\\) accounts for affine offsets from linearization.</p>"},{"location":"03_planning_and_control/#32-optimal-control-problem","title":"3.2. Optimal Control Problem","text":"<p>The MPC minimizes a quadratic cost function over a finite horizon \\(H\\):</p> \\[ \\begin{aligned} \\min_{x_{0:H},\\,u_{0:H-1}} \\quad &amp; \\sum_{k=0}^{H} \\lVert x_k - x_k^{\\mathrm{ref}} \\rVert_Q^2 + \\sum_{k=0}^{H-1} \\lVert u_k - u_k^{\\mathrm{ref}} \\rVert_R^2 \\\\n\\text{s.t.} \\quad &amp; x_{k+1} = A_k x_k + B_k u_k + c_k, \\\\n&amp; v_{\\min} \\le v_k \\le v_{\\max}, \\\\n&amp; |\\delta_k| \\le \\delta_{\\max}, \\\\n&amp; |\\dot{\\delta}_k| \\le \\dot{\\delta}_{\\max}, \\\\n&amp; x_0 = x_{\\mathrm{meas}}. \\end{aligned} \\] <p>Here:</p> <ul> <li>\\(Q\\) and \\(R\\) are positive definite weighting matrices.</li> <li>\\(x_k^{\\mathrm{ref}}\\) and \\(u_k^{\\mathrm{ref}}\\) are derived from the smoothed spline.</li> <li>Constraints ensure dynamic feasibility and actuator safety.</li> </ul>"},{"location":"03_planning_and_control/#33-execution-and-receding-horizon","title":"3.3. Execution and Receding Horizon","text":"<p>Only the first optimal control \\(u_0^*\\) is applied. The process repeats at every sampling step, re-linearizing and resolving the optimization. This receding-horizon strategy provides feedback correction against disturbances and modeling errors.</p>"},{"location":"03_planning_and_control/#34-numerical-stability-and-solver-implementation","title":"3.4. Numerical Stability and Solver Implementation","text":"<ul> <li>The QP is solved using a dense active-set or interior-point method (e.g., qpOASES or OSQP).</li> <li>Jacobians are updated incrementally for real-time feasibility.</li> <li>Constraints are enforced via inequality matrices \\(Gx \\le h\\).</li> </ul>"},{"location":"03_planning_and_control/#35-visualization-and-logging","title":"3.5. Visualization and Logging","text":"<p>During operation:</p> <ul> <li>Predicted horizons \\(\\{x_k\\}_{k=0}^{H}\\) are visualized as green dashed lines.</li> <li>Logs capture solver iterations, constraint activations, and state deviations.</li> <li>All planner and controller metrics are timestamped for post-run correlation.</li> </ul>"},{"location":"03_planning_and_control/#4-summary","title":"4. Summary","text":"<p>The integrated pipeline ensures:</p> <ol> <li>Theoretical optimality: via FMT\u2019s asymptotic convergence.</li> <li>Geometric safety: through inflated obstacle handling and revalidation.</li> <li>Smooth, differentiable paths: ensuring controller compatibility.</li> <li>Dynamic feasibility: via constrained MPC optimization.</li> </ol> <p>The result is a modular, scientifically grounded motion planning and control framework suitable for autonomous vehicle simulation and deployment.</p>"},{"location":"04_simulation_and_visualization/","title":"Simulation and Visualization","text":""},{"location":"04_simulation_and_visualization/#overview","title":"Overview","text":"<p>This document presents a detailed scientific description of the Simulation and Visualization subsystems, which form the execution and diagnostic layer of the planning and control framework. These modules provide deterministic vehicle motion simulation, consistent data logging, and high-fidelity visualization for both analysis and presentation.</p>"},{"location":"04_simulation_and_visualization/#1-deterministic-simulation","title":"1. Deterministic Simulation","text":""},{"location":"04_simulation_and_visualization/#11-model-integration","title":"1.1. Model Integration","text":"<p>The simulator (<code>src/sim/simulator.py</code>) integrates the kinematic bicycle model with a fixed timestep \\(\\Delta t\\). The model propagates the vehicle state forward by applying the latest MPC control command while recording dynamic and error metrics. This implementation ensures bitwise deterministic behavior and repeatable simulations.</p> <p>The discrete-time state propagation equations are:</p> \\[ \\begin{aligned} x_{k+1} &amp;= x_k + v_k \\cos(\\psi_k) \\, \\Delta t, \\ y_{k+1} &amp;= y_k + v_k \\sin(\\psi_k) \\, \\Delta t, \\ \\psi_{k+1} &amp;= \\psi_k + \\frac{v_k}{L} \\tan(\\delta_k) \\, \\Delta t, \\ v_{k+1} &amp;= v_k + a_k \\, \\Delta t, \\end{aligned} \\] <p>where:</p> <ul> <li>\\((x_k, y_k)\\) are planar coordinates,</li> <li>\\(\\psi_k\\) is yaw angle,</li> <li>\\(v_k\\) is longitudinal velocity,</li> <li>\\(\\delta_k\\) is steering angle,</li> <li>\\(a_k\\) is longitudinal acceleration,</li> <li>\\(L\\) is vehicle wheelbase.</li> </ul>"},{"location":"04_simulation_and_visualization/#12-determinism-and-numerical-integrity","title":"1.2. Determinism and Numerical Integrity","text":"<p>A deterministic <code>for</code> loop executes exactly \\(N = \\lceil T / \\Delta t \\rceil\\) iterations for a simulation horizon \\(T\\). The iteration count is fixed to avoid cumulative floating-point drift that can arise from iterative addition of \\(\\Delta t\\). Thus, repeated runs with identical initial states and inputs yield identical logs.</p> <p>The simulation loop terminates early if both:</p> <ol> <li>The vehicle reaches the final waypoint or corridor endpoint, and</li> <li>The speed \\(v_k\\) falls below a configurable stop threshold.</li> </ol> <p>This prevents unnecessary integration beyond steady-state conditions, optimizing computational efficiency while preserving the entire recorded history.</p>"},{"location":"04_simulation_and_visualization/#13-dynamic-quantities-and-derived-metrics","title":"1.3. Dynamic Quantities and Derived Metrics","text":"<p>In addition to the kinematic states, the simulator computes several secondary physical quantities:</p> \\[ \\begin{aligned} \\kappa_k &amp;= \\frac{\\tan(\\delta_k)}{L}, \\ a_{y,k} &amp;= v_k^2 \\kappa_k, \\end{aligned} \\] <p>where:</p> <ul> <li>\\(\\kappa_k\\) is instantaneous curvature,</li> <li>\\(a_{y,k}\\) is lateral acceleration.</li> </ul> <p>These quantities enable monitoring of turning behavior, slip tendencies, and dynamic aggressiveness.</p> <p>Before integration, both \\(a_k\\) and \\(\\delta_k\\) are saturated to their configured limits, ensuring bounded lateral forces and avoiding numerical instability.</p>"},{"location":"04_simulation_and_visualization/#14-simulation-log-structure","title":"1.4. Simulation Log Structure","text":"<p>The simulation results are encapsulated in a structured <code>SimulationLog</code> object containing:</p> <ul> <li>State trajectories: position, velocity, curvature, and steering angle.</li> <li>Tracking metrics: lateral and heading errors relative to the smoothed corridor.</li> <li>Progress indicators: arc-length or time-based advancement along the reference path.</li> <li>MPC predictions: full predicted horizons for each control cycle.</li> <li>Vehicle dynamics diagnostics: slip ratio, lateral acceleration, and force proxies.</li> </ul> <p>These datasets allow for offline analysis, post-run replay, and quantitative benchmarking without re-executing simulations.</p>"},{"location":"04_simulation_and_visualization/#2-visualization-system","title":"2. Visualization System","text":""},{"location":"04_simulation_and_visualization/#21-architecture-overview","title":"2.1. Architecture Overview","text":"<p>The visualization subsystem is implemented in the <code>src/vis</code> package and comprises modular components specialized for static plots, dynamic animations, and planner debugging.</p> <pre><code>flowchart LR\n    L[Simulation Log] --&gt; D[Dashboard Plot]\n    L --&gt; A[Animated GIF]\n    L --&gt; H[Horizon Overlay]\n    P[FMT Edge History] --&gt; F[FMT Debug Window]</code></pre> <p>Each module serves a defined diagnostic or presentation role, enabling layered introspection of the system\u2019s behavior.</p>"},{"location":"04_simulation_and_visualization/#22-module-descriptions","title":"2.2. Module Descriptions","text":""},{"location":"04_simulation_and_visualization/#basepy","title":"<code>base.py</code>","text":"<p>Provides core rendering utilities:</p> <ul> <li>Axes and subplot configuration.</li> <li>Horizon and vehicle overlay primitives.</li> <li> <p>Occupancy grid visualization with three-layer color encoding:</p> </li> <li> <p>Free space (\\(\\mathcal{X}_{\\mathrm{free}}\\))</p> </li> <li>Inflated safety margin (\\(\\mathcal{I}\\))</li> <li>Hard obstacles (\\(\\mathcal{O}\\))</li> </ul> <p>Color differentiation ensures planners and trajectories are visible without obscuring true obstacle extents.</p>"},{"location":"04_simulation_and_visualization/#dashboardpy","title":"<code>dashboard.py</code>","text":"<p>Generates a comprehensive nine-panel diagnostic figure including:</p> <ol> <li>Map and trajectory overlay.</li> <li>Velocity profile.</li> <li>Acceleration profile.</li> <li>Steering angle trajectory.</li> <li>Combined control magnitude.</li> <li>Lateral and heading tracking errors.</li> <li>Corridor progress versus time.</li> <li>Lateral force estimates.</li> <li>Slip indicators.</li> </ol> <p>This dashboard consolidates performance metrics and physical quantities in a unified layout for visual inspection and quantitative analysis.</p>"},{"location":"04_simulation_and_visualization/#animationpy","title":"<code>animation.py</code>","text":"<p>Produces animated GIFs of vehicle motion and MPC operation:</p> <ul> <li>Vehicle pose evolution.</li> <li>Predicted MPC horizons.</li> <li>Control actuation traces over time.</li> <li>Color-coded occupancy and corridor visualization.</li> </ul> <p>Animations use a fixed frame interval synchronized with simulation timesteps to maintain temporal fidelity.</p>"},{"location":"04_simulation_and_visualization/#fmt_debugpy","title":"<code>fmt_debug.py</code>","text":"<p>An optional planner diagnostic tool visualizing:</p> <ul> <li>Randomly sampled points.</li> <li>Feasible edges accepted by FMT.</li> <li>Final collision-free corridor.</li> </ul> <p>Useful for verifying connectivity radius \\(r_n\\), sampling density, and clearance margins during algorithm tuning.</p>"},{"location":"04_simulation_and_visualization/#vehiclepy","title":"<code>vehicle.py</code>","text":"<p>Defines reusable rendering routines for the 2D vehicle footprint and steering geometry. These visual primitives are used consistently across the dashboard and animation modules to ensure uniform representation.</p>"},{"location":"04_simulation_and_visualization/#23-customization-and-extensibility","title":"2.3. Customization and Extensibility","text":"<p>All visual elements are constructed using Matplotlib, allowing direct style modification:</p> <ul> <li>Line widths, colors, and markers.</li> <li>Font sizes and figure ratios.</li> <li>Optional stylesheet injection for global appearance control.</li> </ul> <p>This modular structure facilitates integration into alternative backends or interactive environments without altering the core simulation outputs.</p>"},{"location":"04_simulation_and_visualization/#3-summary","title":"3. Summary","text":"<p>The Simulation and Visualization subsystems provide deterministic, analytically consistent, and fully reproducible motion traces for autonomous vehicle experiments. Key properties include:</p> <ol> <li>Deterministic integration: Fixed-grid numerical propagation with zero stochastic variance.</li> <li>Comprehensive logging: All physical and control quantities stored for reproducibility.</li> <li>Hierarchical visualization: Multi-level inspection from raw logs to animated reconstructions.</li> <li>Safety consistency: Visual validation of corridor adherence and curvature constraints.</li> </ol> <p>Together, these modules create a scientifically verifiable simulation and visualization framework that ensures both quantitative and qualitative transparency in motion planning and control evaluation.</p>"},{"location":"05_configuration_and_cli/","title":"Configuration and CLI Workflows","text":"<p>Scenario YAML files configure the entire pipeline. Each scenario contains five core sections whose parameters are consumed by strongly typed dataclasses in <code>src/common/config.py</code>.</p> <ol> <li>map \u2013 points to a PNG (white = driveable, black = occupied), specifies resolution (<code>meters_per_cell</code>), and defines the world origin of the bitmap.</li> <li>start / goal \u2013 three-element poses <code>[x, y, yaw]</code> expressed in metres and radians. For the bundled <code>map_raw.png</code>    (80 m \u00d7 40 m) the conservative scenario starts at <code>(5, 5)</code> and targets <code>(35, 32)</code> while the high-speed scenario    finishes near <code>(72, 32)</code>.</li> <li>planner_config \u2013 sampling radius, neighbour count, smoothing options, and safety margins for FMT.</li> <li>tracker_config \u2013 MPC horizon length, timestep, weighting matrices, and cruise-speed targets.</li> <li>visualization \u2013 toggles for planner debug windows, animation outputs, file locations, and vehicle drawing params.</li> </ol> <pre><code>map:\n  png_path: maps/map_raw.png\n  meters_per_cell: 0.2\n  origin: [0.0, 0.0]\nstart: [5.0, 5.0, 0.0]\ngoal: [35.0, 32.0, 0.0]\nvisualization:\n  show_planner_debug: true\n  animate_planner: true\n  animate_simulation: true\n  vehicle_draw:\n    wheelbase: 2.7\n    width: 1.55\n    length: 4.5\n    front_overhang: 0.9\n    rear_overhang: 0.8\n    wheel_track: 1.2\n    tire_radius: 0.33\n    tire_width: 0.22\n</code></pre> <p>The <code>meters_per_cell</code> value \\(m_{\\mathrm{cell}}\\) acts as a scale factor when converting between pixel indices \\((i, j)\\) and metric coordinates \\((x, y)\\):</p> \\[   x = x_0 + i \\cdot m_{\\mathrm{cell}}, \\qquad y = y_0 + j \\cdot m_{\\mathrm{cell}}, \\] <p>where \\((x_0, y_0)\\) denotes the <code>origin</code> specified in the YAML file. This mapping is used symmetrically when rendering simulation results back onto the occupancy grid.</p>"},{"location":"05_configuration_and_cli/#cli-modes","title":"CLI Modes","text":"<p>The entry point <code>python -m src.cli &lt;config&gt; &lt;mode&gt;</code> (or the installed console script <code>fmt-cli &lt;config&gt; &lt;mode&gt;</code>) supports four execution modes:</p> <ul> <li><code>plan_only</code> \u2013 run mapping + FMT to inspect the planned corridor and optional debug plot.</li> <li><code>track_only</code> \u2013 run planning and generate the first MPC command without stepping the simulator.</li> <li><code>run_e2e</code> \u2013 complete pipeline from planning through simulation and visualisation.</li> <li><code>export_map</code> \u2013 inflate and export the occupancy grid referenced by the scenario.</li> </ul> <p>Enable or disable plots and animations in the <code>visualization</code> block without modifying code. Output directories default to <code>artifacts/&lt;scenario_name&gt;/</code> and are created automatically.</p>"},{"location":"06_results/","title":"Results","text":"<p>This section presents a comprehensive visualization of the simulation results generated by the Fast Marching Tree (FMT) motion planning stack. Each scenario represents a unique vehicle configuration and driving style, highlighting how the FMT algorithm adapts its path generation, control strategy, and exploration behavior under consistent simulation conditions.</p> <p>The following results illustrate the planner\u2019s performance across a spectrum of physical and control constraints, from conservative to aggressive driving profiles. All simulations were executed using identical initial states, cost functions, and environmental parameters to ensure objective comparison. To guarantee reproducibility, every run employed a deterministic simulator with fixed random seeds, providing bitwise-consistent outcomes across tests.</p>"},{"location":"06_results/#aggressive","title":"Aggressive","text":"<p>The Aggressive configuration represents a high-speed, high-curvature driving mode that prioritizes fast goal-reaching over smoothness. It typically uses a shorter planning horizon and a higher acceleration limit.</p>"},{"location":"06_results/#bus","title":"Bus","text":"<p>The Bus scenario simulates a long-wheelbase vehicle with limited steering angle and slower acceleration dynamics. It demonstrates the planner\u2019s ability to handle nonholonomic constraints in large vehicles operating in narrow spaces.</p>"},{"location":"06_results/#conservative","title":"Conservative","text":"<p>The Conservative configuration favors stability and safety, maintaining low curvature and acceleration bounds. It is designed to simulate cautious driving styles or heavy-load vehicles that must minimize control effort.</p>"},{"location":"06_results/#sport","title":"Sport","text":"<p>The Sport setup models agile and responsive handling behavior suitable for fast maneuvering and performance driving. It typically operates with higher steering gains, moderate acceleration, and sharper trajectory curvature.</p>"},{"location":"06_results/#van","title":"Van","text":"<p>The Van configuration demonstrates moderate-speed motion with medium steering and acceleration limits, representing a balanced driving profile between aggressive and conservative modes.</p>"}]}